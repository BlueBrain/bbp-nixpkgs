# begin_generated_IBM_copyright_prolog                             
#                                                                  
# This is an automatically generated copyright prolog.             
# After initializing,  DO NOT MODIFY OR MOVE                       
# ================================================================ 
#                                                                  
# Licensed Materials - Property of IBM                             
# Blue Gene/Q                                                      
# (C) Copyright IBM Corp. 2012  All Rights Reserved                 
# US Government Users Restricted Rights - Use,                     
# duplication or disclosure restricted by GSA ADP                  
# Schedule contract with IBM Corp.                                 
#                                                                  
# This software is available to you under the                      
# GNU General Public License (GPL).                                
#                                                                  
# ================================================================ 
#                                                                  
# end_generated_IBM_copyright_prolog                               
Index: ld/emultempl/elf32.em
===================================================================
--- a/ld/emultempl/elf32.em	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/ld/emultempl/elf32.em	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -1265,13 +1265,11 @@
 						  &n, force))
 	    break;
 EOF
-if [ "x${USE_LIBPATH}" = xyes ] ; then
 fragment <<EOF
 	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
 						  &n, force))
 	    break;
 EOF
-fi
 if [ "x${NATIVE}" = xyes ] ; then
 fragment <<EOF
 	  if (command_line.rpath_link == NULL
Index: ld/scripttempl/elf.sc
===================================================================
--- a/ld/scripttempl/elf.sc	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/ld/scripttempl/elf.sc	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -333,7 +333,7 @@
 SECTIONS
 {
   /* Read-only sections, merged into text segment: */
-  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+PROVIDE (__executable_start = ${TEXT_START_ADDR}); . = ${TEXT_BASE_ADDRESS};}}}
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+ __executable_start = ${TEXT_START_ADDR}; . = ${TEXT_BASE_ADDRESS};}}}
   ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR}${SIZEOF_HEADERS_CODE};}}
   ${CREATE_PIE+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR}${SIZEOF_HEADERS_CODE};}}
 EOF
@@ -527,9 +527,13 @@
   .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }
   .gcc_except_table ${RELOCATING-0} : ONLY_IF_RO { *(.gcc_except_table
   .gcc_except_table.*) }
+
   /* These sections are generated by the Sun/Oracle C++ compiler.  */
   .exception_ranges ${RELOCATING-0} : ONLY_IF_RO { *(.exception_ranges
   .exception_ranges*) }
+  /* Set 1MB Alignment for CNK, and ensure there is at least 4KB between text
+     and data for the kernel_info structure. */
+  ${RELOCATING+. += 0x1000; . = ALIGN (0x100000);}
 
   /* Adjust the address for the data segment.  We want to adjust up to
      the same address within the page on the next page up.  */
Index: ld/emulparams/elf64ppc.sh
===================================================================
--- a/ld/emulparams/elf64ppc.sh	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/ld/emulparams/elf64ppc.sh	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -7,7 +7,7 @@
 SCRIPT_NAME=elf
 OUTPUT_FORMAT="elf64-powerpc"
 NO_REL_RELOCS=yes
-TEXT_START_ADDR=0x10000000
+TEXT_START_ADDR=0x1000000
 #SEGMENT_SIZE=0x10000000
 MAXPAGESIZE="CONSTANT (MAXPAGESIZE)"
 COMMONPAGESIZE="CONSTANT (COMMONPAGESIZE)"
Index: gas/config/tc-ppc.c
===================================================================
--- a/gas/config/tc-ppc.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/gas/config/tc-ppc.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -1297,6 +1297,7 @@
 -mppc64bridge           generate code for PowerPC 64, including bridge insns\n\
 -mbooke                 generate code for 32-bit PowerPC BookE\n\
 -ma2                    generate code for A2 architecture\n\
+-ma2q                   generate code for A2+QPX architecture\n\
 -mpower4, -mpwr4        generate code for Power4 architecture\n\
 -mpower5, -mpwr5, -mpwr5x\n\
                         generate code for Power5 architecture\n\
@@ -1349,7 +1350,11 @@
   if ((ppc_cpu & ~(ppc_cpu_t) PPC_OPCODE_ANY) == 0)
     {
       if (ppc_obj64)
-	ppc_cpu |= PPC_OPCODE_PPC | PPC_OPCODE_64;
+       // Right now this is hardcoded for the BGQ/QPX opcode set
+	ppc_cpu |= (PPC_OPCODE_PPC | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_ISEL
+		| PPC_OPCODE_POWER5 | PPC_OPCODE_CACHELCK
+		| PPC_OPCODE_A2 | PPC_OPCODE_QPX);
       else if (strncmp (default_os, "aix", 3) == 0
 	       && default_os[3] >= '4' && default_os[3] <= '9')
 	ppc_cpu |= PPC_OPCODE_COMMON;
Index: include/opcode/ppc.h
===================================================================
--- a/include/opcode/ppc.h	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/include/opcode/ppc.h	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -170,6 +170,9 @@
 /* Opcode is supported by PowerPC 476 processor.  */
 #define PPC_OPCODE_476		0x40000000
 
+/* Opcode is supported by QPX (BGQ).  */
+#define PPC_OPCODE_QPX           0x400000000ULL
+
 /* Opcode is supported by AppliedMicro Titan core */
 #define PPC_OPCODE_TITAN        0x80000000
 
@@ -353,6 +356,10 @@
    prints these with a leading 'v'.  */
 #define PPC_OPERAND_VR (0x2000)
 
+/* This operand names a qpx vector unit register.  The disassembler
+    prints these with a leading 'q'.  */
+#define PPC_OPERAND_QR (0x200000)
+
 /* This operand is for the DS field in a DS form instruction.  */
 #define PPC_OPERAND_DS (0x4000)
 
Index: libiberty/cp-demangle.c
===================================================================
--- a/libiberty/cp-demangle.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/libiberty/cp-demangle.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -1527,9 +1527,19 @@
 d_identifier (struct d_info *di, int len)
 {
   const char *name;
-
+  struct demangle_component *ret;
   name = d_str (di);
 
+  /* Special case for the mangled name generated by the XL compiler for a quad vector.  */
+  /* The mangled name u10__vector4d should be demangled as __vector4double. */
+
+  if (strncmp(name, "__vector4d", 10) == 0) {
+    ret = d_make_name (di, "__vector4double", 15);
+    d_advance(di, 10);
+    return ret;
+  }
+
+
   if (di->send - name < len)
     return NULL;
 
@@ -2147,6 +2157,10 @@
       d_advance (di, 1);
       ret = d_make_comp (di, DEMANGLE_COMPONENT_VENDOR_TYPE,
 			 d_source_name (di), NULL);
+    /* This is a bug in the base GNU code.  Substitutions are not allowed for vendor types at this level, only if
+       there is a pointer or reference modifier. */
+  
+       can_subst = 0;
       break;
 
     case 'F':
Index: binutils/readelf.c
===================================================================
--- a/binutils/readelf.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/binutils/readelf.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -12722,6 +12722,12 @@
   return 1;
 }
 
+ static const char *
+get_bgq_elf_note_type (void)
+{
+  return _("NT_BGQ_BUILD_ID_TAG (BlueGene/Q build id tag)");
+}
+
 static const char *
 get_netbsd_elfcore_note_type (unsigned e_type)
 {
@@ -12961,7 +12967,7 @@
 {
   const char * name = pnote->namesz ? pnote->namedata : "(NONE)";
   const char * nt;
-
+  int isBGQ = 0;
   if (pnote->namesz == 0)
     /* If there is no note name, then use the default set of
        note type strings.  */
@@ -12970,6 +12976,11 @@
   else if (const_strneq (pnote->namedata, "GNU"))
     /* GNU-specific object file notes.  */
     nt = get_gnu_elf_note_type (pnote->type);
+  else if (const_strneq (pnote->namedata, "BGQ")) {
+    /* BGQ-specific object file notes.  */
+    nt = get_bgq_elf_note_type ();
+    isBGQ = 1;
+  }
 
   else if (const_strneq (pnote->namedata, "NetBSD-CORE"))
     /* NetBSD-specific core file notes.  */
@@ -12995,7 +13006,7 @@
     nt = get_note_type (pnote->type);
 
   printf ("  %-20s 0x%08lx\t%s\n", name, pnote->descsz, nt);
-
+  if (isBGQ) printf("  \t\t\t\t%s %s\n", pnote->descdata, ((char*)(pnote->descdata))+8);
   if (const_strneq (pnote->namedata, "IPF/VMS"))
     return print_ia64_vms_note (pnote);
   else if (const_strneq (pnote->namedata, "GNU"))
Index: binutils/objdump.c
===================================================================
--- a/binutils/objdump.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/binutils/objdump.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -3436,6 +3436,9 @@
   bfd_init ();
   set_default_bfd_target ();
 
+  /* Set the default disassembler machine type to a2q for BGQ. */
+  disassembler_options = "a2q";
+
   while ((c = getopt_long (argc, argv,
 			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
 			   long_options, (int *) 0))
Index: binutils/Makefile.am
===================================================================
--- a/binutils/Makefile.am	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/binutils/Makefile.am	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -73,7 +73,7 @@
 EXTRA_PROGRAMS = $(NLMCONV_PROG) srconv sysdump coffdump $(DLLTOOL_PROG) $(WINDRES_PROG) $(WINDMC_PROG) $(DLLWRAP_PROG)
 
 # Stuff that goes in tooldir/ if appropriate.
-TOOL_PROGS = nm-new strip-new ar ranlib dlltool objdump objcopy
+TOOL_PROGS = nm-new strip-new ar ranlib dlltool objdump objcopy strings
 
 BASEDIR = $(srcdir)/..
 BFDDIR = $(BASEDIR)/bfd
Index: binutils/Makefile.in
===================================================================
--- a/binutils/Makefile.in	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/binutils/Makefile.in	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -446,7 +446,7 @@
 RENAMED_PROGS = $(NM_PROG) $(STRIP_PROG) $(DEMANGLER_PROG)
 
 # Stuff that goes in tooldir/ if appropriate.
-TOOL_PROGS = nm-new strip-new ar ranlib dlltool objdump objcopy
+TOOL_PROGS = nm-new strip-new ar ranlib dlltool objdump objcopy strings
 BASEDIR = $(srcdir)/..
 BFDDIR = $(BASEDIR)/bfd
 INCDIR = $(BASEDIR)/include
Index: bfd/elf64-ppc.c
===================================================================
--- a/bfd/elf64-ppc.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/bfd/elf64-ppc.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -120,7 +120,7 @@
 
 /* The name of the dynamic interpreter.  This is put in the .interp
    section.  */
-#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"
+#define ELF_DYNAMIC_INTERPRETER "/lib64/bgq/ld64.so.1"
 
 /* The size in bytes of an entry in the procedure linkage table.  */
 #define PLT_ENTRY_SIZE 24
@@ -11082,43 +11082,24 @@
 
   if (htab->multi_toc_needed)
     {
-      /* If a code section has a function that uses the TOC then we need
-	 to use the right TOC (obviously).  Also, make sure that .opd gets
-	 the correct TOC value for R_PPC64_TOC relocs that don't have or
-	 can't find their function symbol (shouldn't ever happen now).
-	 Also specially treat .fixup for the linux kernel.  .fixup
-	 contains branches, but only back to the function that hit an
-	 exception.  */
-      if (isec->has_toc_reloc
-	  || (isec->flags & SEC_CODE) == 0
-	  || strcmp (isec->name, ".fixup") == 0)
-	{
-	  if (elf_gp (isec->owner) != 0)
-	    htab->toc_curr = elf_gp (isec->owner);
-	}
-      else
-	{
-	  if (!isec->call_check_done
-	      && toc_adjusting_stub_needed (info, isec) < 0)
-	    return FALSE;
-	  /* If we make a local call from this section, ie. a branch
-	     without a following nop, then we have no place to put a
-	     toc restoring insn.  We must use the same toc group as
-	     the callee.
-	     Testing makes_toc_func_call actually tests for *any*
-	     calls to functions that need a good toc pointer.  A more
-	     precise test would be better, as this one will set
-	     incorrect values for pasted .init/.fini fragments.
-	     (Fixed later in check_pasted_section.)  */
-	  if (isec->makes_toc_func_call
-	      && elf_gp (isec->owner) != 0)
-	    htab->toc_curr = elf_gp (isec->owner);
-	}
+        /* Analyse sections that aren't already flagged as needing a
+           valid toc pointer.  Exclude .fixup for the linux kernel.
+           .fixup contains branches, but only back to the function that
+            hit an exception.  */
+      if (!(isec->has_toc_reloc
+            || (isec->flags & SEC_CODE) == 0
+            || strcmp (isec->name, ".fixup") == 0
+            || isec->call_check_done))
+        {
+          if (toc_adjusting_stub_needed (info, isec) < 0)
+            return FALSE;
+        }
+      if (elf_gp (isec->owner) != 0)
+        htab->toc_curr = elf_gp (isec->owner);
+
     }
 
-  /* Functions that don't use the TOC can belong in any TOC group.
-     Use the last TOC base.  */
-  htab->stub_group[isec->id].toc_off = htab->toc_curr;
+htab->stub_group[isec->id].toc_off = htab->toc_curr;
   return TRUE;
 }
 
Index: opcodes/ppc-dis.c
===================================================================
--- a/opcodes/ppc-dis.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/opcodes/ppc-dis.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -87,7 +87,11 @@
 		| PPC_OPCODE_POWER5 | PPC_OPCODE_CACHELCK | PPC_OPCODE_64
 		| PPC_OPCODE_A2),
     0 },
-  { "altivec", (PPC_OPCODE_PPC),
+  { "a2q",      (PPC_OPCODE_PPC | PPC_OPCODE_ISEL
+                | PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_CACHELCK
+                | PPC_OPCODE_64 | PPC_OPCODE_A2 | PPC_OPCODE_QPX),
+    0 },
+{ "altivec", (PPC_OPCODE_PPC),
     PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 },
   { "any",     0,
     PPC_OPCODE_ANY },
@@ -681,6 +685,8 @@
 	    (*info->fprintf_func) (info->stream, "v%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_VSR) != 0)
 	    (*info->fprintf_func) (info->stream, "vs%ld", value);
+          else if ((operand->flags & PPC_OPERAND_QR) != 0)
+            (*info->fprintf_func) (info->stream, "q%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
 	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
Index: opcodes/ppc-opc.c
===================================================================
--- a/opcodes/ppc-opc.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/opcodes/ppc-opc.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -117,6 +117,12 @@
 static long extract_vleui (unsigned long, ppc_cpu_t, int *);
 static unsigned long insert_vleil (unsigned long, long, ppc_cpu_t, const char **);
 static long extract_vleil (unsigned long, ppc_cpu_t, int *);
+static unsigned long insert_th (unsigned long, long, ppc_cpu_t, const char **);
+static unsigned long insert_th0 (unsigned long, long, ppc_cpu_t, const char **);
+static unsigned long insert_th8 (unsigned long, long, ppc_cpu_t, const char **);
+static unsigned long insert_l012 (unsigned long, long, ppc_cpu_t, const char **);
+static unsigned long insert_l013 (unsigned long, long, ppc_cpu_t, const char **);
+static unsigned long ignore_operand (unsigned long, long, ppc_cpu_t, const char **);
 
 /* The operands table.
 
@@ -390,8 +396,16 @@
 #define L IMM20 + 1
   { 0x1, 21, NULL, NULL, PPC_OPERAND_OPTIONAL },
 
+  /* The L field in a D or X form instruction is 2 bits where values 0,1,3 are valid (dcbf).  */
+#define L013 L + 1
+  { 0x3, 21, insert_l013, NULL, PPC_OPERAND_OPTIONAL },
+
+  /* The L field in a D or X form instruction is 2 bits where values 0,1,2 are valid (wclr).  */
+#define L012 L013 + 1
+  { 0x3, 21, insert_l012, NULL, PPC_OPERAND_OPTIONAL },
+
   /* The LEV field in a POWER SVC form instruction.  */
-#define SVC_LEV L + 1
+#define SVC_LEV L012 + 1
   { 0x7f, 5, NULL, NULL, 0 },
 
   /* The LEV field in an SC form instruction.  */
@@ -602,8 +616,24 @@
 #define SPR_MASK (0x3ff << 11)
   { 0x3ff, 11, insert_spr, extract_spr, 0 },
 
+/* The literal field in an X form instruction, which is a 12 bit field
+   to be used as an immediate value.  Similar to the SPR field. */       
+#define LIT SPR + 1
+#define LIT_MASK (0xfff << 9)
+  { 0xfff, 9, NULL, NULL, 0 },
+/* The literal field in an X form instruction, which is a 2 bit field
+   to be used as an immediate value.  Similar to the SPR field. */       
+#define QVD LIT + 1
+#define QVD_MASK (0x3 << 9)
+  { 0x3, 9, NULL, NULL, 0 },
+/* The literal field in an X form instruction, which is a 4 bit field
+   to be used as an immediate value.  Similar to the SPR field. */       
+#define QTTTT QVD + 1
+#define QTTTT_MASK (0xf << 7)
+  { 0xf, 7, NULL, NULL, 0 },
+
   /* The BAT index number in an XFX form m[ft]ibat[lu] instruction.  */
-#define SPRBAT SPR + 1
+#define SPRBAT QTTTT + 1
 #define SPRBAT_MASK (0x3 << 17)
   { 0x3, 17, NULL, NULL, 0 },
 
@@ -841,13 +871,118 @@
 
 #define ERAT_T UIM + 1
   { 0x7, 21, NULL, NULL, 0 },
+/*
+   QPX unit operand definitions
+*/
+  /* The QRA field in an X or A form instruction.  */
+#define QRA ERAT_T + 1
+#define QRA_MASK (0x1f << 16)
+  { 0x1f, 16, NULL, NULL, PPC_OPERAND_QR },
+
+  /* The QRB field in an X or A form instruction.  */
+#define QRB QRA + 1
+#define QRB_MASK (0x1f << 11)
+  { 0x1f, 11, NULL, NULL, PPC_OPERAND_QR },
+
+  /* The QRC field in an A form instruction.  */
+#define QRC QRB + 1
+#define QRC_MASK (0x1f << 6)
+  { 0x1f, 6, NULL, NULL, PPC_OPERAND_QR },
+
+  /* The QRS field in an X form instruction or the QRT field in a D, X
+     or A form instruction.  */
+#define QRS QRC + 1
+#define QRT QRS
+  { 0x1f, 21, NULL, NULL, PPC_OPERAND_QR },
+  /* recycle existing duplicate operand definitions */
+#define QAT BAT
+#define QBA BBA
+
+  /* The TH field in a dcbt or dcbst instruction.  */
+#define TH QRS + 1
+  { 0x1f, 21, insert_th, NULL, PPC_OPERAND_OPTIONAL },
+  /* The TH field in a dcbtct or dcbstct instruction.  */
+#define TH0 TH + 1
+  { 0x1f, 21, insert_th0, NULL, PPC_OPERAND_OPTIONAL },
+  /* The TH field in a dcbtds or dcbstds instruction.  */
+#define TH8 TH0 + 1
+  { 0x1f, 21, insert_th8, NULL, PPC_OPERAND_OPTIONAL },
+
+  /* define an operand as ignored - this is used to redefine PPC403 instructions
+ *       that have different meanings or forms on PPCA2  */
+#define OP_IGN TH8 + 1
+  { 0x1f, 0, ignore_operand, NULL, PPC_OPERAND_OPTIONAL },
+
 };
-
 const unsigned int num_powerpc_operands = (sizeof (powerpc_operands)
 					   / sizeof (powerpc_operands[0]));
 
 /* The functions used to insert and extract complicated operands.  */
+static unsigned long
+ignore_operand (unsigned long insn,
+            long value ATTRIBUTE_UNUSED,
+            ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+            const char **errmsg ATTRIBUTE_UNUSED)
+{
+   return insn;    // return just the opcode - ignore operand
+}
 
+static unsigned long
+insert_th (unsigned long insn,
+            long value,
+            ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+            const char **errmsg)
+{
+  if (value < 0 || value >16)
+    *errmsg = "TH operand must be 0 to 16 ";
+  return insn | ((value & 0x1f) << 21);
+}
+static unsigned long
+insert_th0 (unsigned long insn,
+            long value,
+            ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+            const char **errmsg)
+{
+  if ((value < 0) || (value > 7))
+    *errmsg = "TH operand must be 0 to 7";
+  return insn | ((value & 0x1f) << 21);
+}
+
+static unsigned long
+insert_th8 (unsigned long insn,
+            long value,
+            ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+            const char **errmsg)
+{
+  if ((value != 0) && ((value <8) || (value > 15)))
+    *errmsg = "TH operand must be 0 or 8 to 15";
+  return insn | ((value & 0x1f) << 21);
+}
+
+static unsigned long
+insert_l012 (unsigned long insn,
+            long value,
+            ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+            const char **errmsg)
+{
+  if ((value != 0) && (value >2))
+    *errmsg = "L operand must be 0, 1 or 2";
+  return insn | ((value & 0x03) << 21);
+}
+
+static unsigned long
+insert_l013 (unsigned long insn,
+            long value,
+            ppc_cpu_t dialect ATTRIBUTE_UNUSED,
+            const char **errmsg)
+{
+  if ((value != 0) && ((value > 3) || (2 == value )))
+    *errmsg = "L operand must be 0, 1 or 3";
+  return insn | ((value & 0x03) << 21);
+}
+
+
+
 /* The ARX, ARY, RX and RY operands are alternate encodings of GPRs.  */
 
 static unsigned long
@@ -2368,6 +2503,15 @@
 /* The mask for an X form instruction.  */
 #define X_MASK XRC (0x3f, 0x3ff, 1)
 
+/* The mask for an X form instruction with a 2 bit literal field. */
+#define XLIT_MASK XRC (0x3f, 0xff, 0)
+
+/* An X form instruction with a 4 bit literal as part of the extended op code  */
+#define XTTTT(op, xop) (OP (op) | ((((unsigned long)(xop)) & 0x3f) << 1))
+
+/* The mask for an X form instruction with a 4 bit literal field. */
+#define XTTTT_MASK XRC (0x3f, 0x3f, 0)
+
 /* An X form wait instruction with everything filled in except the WC field.  */
 #define XWC_MASK (XRC (0x3f, 0x3ff, 1) | (7 << 23) | RA_MASK | RB_MASK)
 
@@ -2697,6 +2841,7 @@
 #define PPCRFMCI	PPC_OPCODE_RFMCI
 #define E500MC  PPC_OPCODE_E500MC
 #define PPCA2	PPC_OPCODE_A2
+#define PPCQPX  PPC_OPCODE_QPX
 #define TITAN   PPC_OPCODE_TITAN  
 #define MULHW   PPC_OPCODE_405 | PPC_OPCODE_440 | TITAN | PPC_OPCODE_VLE
 #define E500	PPC_OPCODE_E500
@@ -2727,6 +2872,22 @@
 
 const struct powerpc_opcode powerpc_opcodes[] = {
 {"attn",	X(0,256),	X_MASK,   POWER4|PPCA2,	PPC476,		{0}},
+{"qvfxxmadds",   A(0, 1,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxxcpnmadds",A(0, 3,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxmadds",    A(0, 9,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxxnpmadds", A(0,11,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxmuls",    A(0,17,0),     AFRB_MASK, PPCQPX, PPCNONE, { QRT, QRA,      QRC } },
+{"qvfsubs",     A(0,20,0),     AFRC_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfadds",     A(0,21,0),     AFRC_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfres",      A(0,24,0),  AFRAFRC_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfmuls",     A(0,25,0),     AFRB_MASK, PPCQPX, PPCNONE, { QRT, QRA,      QRC } },
+{"qvfrsqrtes",  A(0,26,0),  AFRAFRC_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfmsubs",    A(0,28,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfmadds",    A(0,29,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfnmsubs",   A(0,30,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfnmadds",   A(0,31,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfcfids",   XRC(0,846,0),    XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfcfidus",  XRC(0,974,0),    XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
 {"tdlgti",	OPTO(2,TOLGT),	OPTO_MASK,   PPC64,	PPCNONE,	{RA, SI}},
 {"tdllti",	OPTO(2,TOLLT),	OPTO_MASK,   PPC64,	PPCNONE,	{RA, SI}},
 {"tdeqi",	OPTO(2,TOEQ),	OPTO_MASK,   PPC64,	PPCNONE,	{RA, SI}},
@@ -2773,6 +2934,80 @@
 {"tnei",	OPTO(3,TONE),	OPTO_MASK,   PWRCOM,	PPCNONE,	{RA, SI}},
 {"twi",		OP(3),		OP_MASK,     PPCCOM,	PPCNONE,	{TO, RA, SI}},
 {"ti",		OP(3),		OP_MASK,     PWRCOM,	PPCNONE,	{TO, RA, SI}},
+{"qvfxxmadd",    A(4, 1,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxxcpnmadd", A(4, 3,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxmadd",     A(4, 9,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfxxnpmadd",  A(4,11,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfsel",       A(4,23,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfcpsgn",    A(4, 8,0),     AFRC_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfxmul",     A(4,17,0),     AFRB_MASK, PPCQPX, PPCNONE, { QRT, QRA,      QRC } },
+{"qvfsub",      A(4,20,0),     AFRC_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfadd",      A(4,21,0),     AFRC_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfre",       A(4,24,0),  AFRAFRC_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfmul",      A(4,25,0),     AFRB_MASK, PPCQPX, PPCNONE, { QRT, QRA,      QRC } },
+{"qvfrsqrte",   A(4,26,0),  AFRAFRC_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfmsub",     A(4,28,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfmadd",     A(4,29,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfnmsub",    A(4,30,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+{"qvfnmadd",    A(4,31,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRC, QRB } },
+// note: qvfperm has a different operand order than other 4 operand instructions
+{"qvfperm",     A(4, 6,0),        A_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB, QRC } },
+{ "qvftstnan",  XO(4, 64,0,0),   XO_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvfcmpgt",   XO(4, 32,0,0),   XO_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvfcmplt",   XO(4, 96,0,0),   XO_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvfcmpeq",   XO(4,  0,0,0),   XO_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvaligni_00",  XRC(4,0x005,0),  X_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvaligni_01",  XRC(4,0x105,0),  X_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvaligni_10",  XRC(4,0x205,0),  X_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvaligni_11",  XRC(4,0x305,0),  X_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{ "qvaligni",     XRC(4,0x05,0), XLIT_MASK, PPCQPX, PPCNONE, { QRT, QRA, QRB, QVD } },
+{ "qvesplati_00", XRC(4,0x025,0),XRB_MASK, PPCQPX, PPCNONE, { QRT, QRA           } },
+{ "qvesplati_01", XRC(4,0x125,0),XRB_MASK, PPCQPX, PPCNONE, { QRT, QRA           } },
+{ "qvesplati_10", XRC(4,0x225,0),XRB_MASK, PPCQPX, PPCNONE, { QRT, QRA           } },
+{ "qvesplati_11", XRC(4,0x325,0),XRB_MASK, PPCQPX, PPCNONE, { QRT, QRA           } },
+{ "qvesplati",    XRC(4,0x25,0),XLIT_MASK, PPCQPX, PPCNONE, { QRT, QRA,      QVD } },
+{ "qvgpci",     XRC(4,133,0),     XLIT_MASK, PPCQPX, PPCNONE, { QRT, LIT          } },
+{"qvfrsp",    XRC(4, 12,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctid",   XRC(4,814,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctidu",  XRC(4,942,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctidz",  XRC(4,815,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctiduz", XRC(4,943,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctiw",   XRC(4, 14,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctiwu",  XRC(4,142,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctiwz",  XRC(4, 15,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfctiwuz", XRC(4,143,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfcfid",   XRC(4,846,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfcfidu",  XRC(4,974,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfrin",    XRC(4,392,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfriz",    XRC(4,424,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfrip",    XRC(4,456,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfrim",    XRC(4,488,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfneg",    XRC(4, 40,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfmr",     XRC(4, 72,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfabs",    XRC(4,264,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+{"qvfnabs",   XRC(4,136,0),     XRA_MASK, PPCQPX, PPCNONE, { QRT,      QRB      } },
+/* The following are extended mnemonics for the qvflogical instruction */
+{"qvfclr",    XRC(4,4,0),       XL_MASK,  PPCQPX, PPCNONE, { QRT, QAT, QBA      } },
+{"qvfand",    XRC(4,68,0),      X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+// skip 2 redundent forms
+{"qvfandc",   XRC(4,260,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfctfb",   XRC(4,324,0),     XL_MASK,  PPCQPX, PPCNONE, { QRT, QRA, QBA      } },
+{"qvfxor",    XRC(4,388,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfor",     XRC(4,452,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfnor",    XRC(4,516,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfequ",    XRC(4,580,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfnot",    XRC(4,644,0),     XL_MASK,  PPCQPX, PPCNONE, { QRT, QRA, QBA      } },
+// skip 2 redundent forms
+{"qvforc",    XRC(4,836,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfnand",   XRC(4,900,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB      } },
+{"qvfset",    XRC(4,964,0),     X_MASK,   PPCQPX, PPCNONE, { QRT, QAT, QBA      } },
+/* 
+   Base qvflogical instruction - note special form for the 4 bit truth table 
+   operation selector as part of the extended op code. This is needed for 
+   the disassembler for forms without extended mnemonics (as if anyone would
+   use then outside a testcase). 
+*/
+{"qvflogical", XTTTT(4,4),  XTTTT_MASK,   PPCQPX, PPCNONE, { QRT, QRA, QRB, QTTTT } },
 
 {"ps_cmpu0",	X  (4,	 0), X_MASK|(3<<21), PPCPS,	PPCNONE,	{BF, FRA, FRB}},
 {"vaddubm",	VX (4,	 0),	VX_MASK,     PPCVEC|PPCVLE, PPCNONE,	{VD, VA, VB}},
@@ -4192,6 +4427,65 @@
 {"rldcr",	MDS(30,9,0),	MDS_MASK,    PPC64,	PPCNONE,	{RA, RS, RB, ME6}},
 {"rldcr.",	MDS(30,9,1),	MDS_MASK,    PPC64,	PPCNONE,	{RA, RS, RB, ME6}},
 
+{"qvlfsx",       XRC(31, 519,0),     X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfsxa",      XRC(31, 519,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfsux",     XRC(31, 551,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfsuxa",     XRC(31, 551,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfdx",      XRC(31, 583,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfdxa",      XRC(31, 583,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfdux",     XRC(31, 615,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfduxa",     XRC(31, 615,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfcsx",     XRC(31,   7,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfcsxa",     XRC(31,   7,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfcsux",    XRC(31,  39,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfcsuxa",    XRC(31,  39,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfcdx",     XRC(31,  71,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfcdxa",     XRC(31,  71,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfcdux",    XRC(31, 103,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfcduxa",    XRC(31, 103,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RAS, RB } },
+{"qvlfiwax",     XRC(31, 871,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfiwaxa",    XRC(31, 871,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfiwzx",     XRC(31, 839,0),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlfiwzxa",    XRC(31, 839,1),      X_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlpcldx",    X(31, 582),      XO_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlpclsx",    X(31, 518),      XO_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlpcrdx",    X(31,  70),      XO_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvlpcrsx",    X(31,   6),      XO_MASK, PPCQPX, PPCNONE, { QRT, RA0, RB } },
+{"qvstfcsxi" ,  XRC(31, 133,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcsxia" , XRC(31, 133,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcsx" ,   XRC(31, 135,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcsxa" ,  XRC(31, 135,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcsuxi" , XRC(31, 165,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcsuxia" ,XRC(31, 165,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcsux" ,  XRC(31, 167,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcsuxa" , XRC(31, 167,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcdxi" ,  XRC(31, 197,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcdxia" , XRC(31, 197,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcdx" ,   XRC(31, 199,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcdxa" ,  XRC(31, 199,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfcduxi" , XRC(31, 229,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcduxia" ,XRC(31, 229,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcdux" ,  XRC(31, 231,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfcduxa" , XRC(31, 231,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfsxi" ,   XRC(31, 645,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfsxia" ,  XRC(31, 645,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfsx" ,    XRC(31, 647,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfsxa" ,   XRC(31, 647,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfsuxi" ,  XRC(31, 677,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfsuxia" , XRC(31, 677,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfsux" ,   XRC(31, 679,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfsuxa" ,  XRC(31, 679,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfdxi" ,   XRC(31, 709,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfdxia" ,  XRC(31, 709,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfdx" ,    XRC(31, 711,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfdxa" ,   XRC(31, 711,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfduxi" ,  XRC(31, 741,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfduxia" , XRC(31, 741,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfdux" ,   XRC(31, 743,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfduxa" ,  XRC(31, 743,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RAS, RB } },
+{"qvstfiwx"  ,  XRC(31, 967,0),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+{"qvstfiwxa"  , XRC(31, 967,1),      X_MASK, PPCQPX, PPCNONE, { QRS, RA0, RB } },
+
 {"cmpw",	XOPL(31,0,0),	XCMPL_MASK,  PPCCOM,	PPCNONE,	{OBF, RA, RB}},
 {"cmpd",	XOPL(31,0,1),	XCMPL_MASK,  PPC64,	PPCNONE,	{OBF, RA, RB}},
 {"cmp",		X(31,0),	XCMP_MASK,   PPC|PPCVLE, PPCNONE,	{BF, L, RA, RB}},
@@ -4375,7 +4669,7 @@
 {"ldarx",	X(31,84),	XEH_MASK,    PPC64|PPCVLE, PPCNONE,	{RT, RA0, RB, EH}},
 
 {"dcbfl",	XOPL(31,86,1),	XRT_MASK,    POWER5,	PPC476,		{RA0, RB}},
-{"dcbf",	X(31,86),	XLRT_MASK,   PPC|PPCVLE, PPCNONE,	{RA0, RB, L}},
+{"dcbf",	X(31,86),	XLRT_MASK,   PPC|PPCVLE, PPCNONE,	{RA0, RB, L013}},
 
 {"lbzx",	X(31,87),	X_MASK,	     COM|PPCVLE, PPCNONE,	{RT, RA0, RB}},
  
@@ -4547,8 +4841,11 @@
 {"mtsri",	X(31,242),	XRA_MASK,    POWER,	NON32,		{RS, RB}},
 
 {"dcbtstt",	XRT(31,246,0x10), XRT_MASK,  POWER7,	PPCNONE,	{RA0, RB}},
-{"dcbtst",	X(31,246),	X_MASK,      POWER4,	PPCNONE,	{RA0, RB, CT}},
-{"dcbtst",	X(31,246),	X_MASK,      PPC|PPCVLE, POWER4,	{CT, RA0, RB}},
+{"dcbtstt",     X(31,246)|(16<<21),     X_MASK,      PPCA2,    PPCNONE,        {RA, RB}},
+//{"dcbtst",   X(31,246),      X_MASK,      POWER4,    PPCNONE,        {RA, RB, CT}},
+{"dcbtst",     X(31,246),      X_MASK,      PPCA2,     PPCNONE,        {CT, RA, RB}},
+{"dcbtstct",    X(31,246),      X_MASK,      PPCA2,    PPCNONE,        { RA, RB, TH0}},
+{"dcbtstds",    X(31,246),      X_MASK,      PPCA2,     PPCNONE,       { RA, RB, TH8}},
  
 {"stbux",	X(31,247),	X_MASK,	     COM|PPCVLE, PPCNONE,	{RS, RAS, RB}},
 
@@ -4599,7 +4896,7 @@
 
 {"lhepx",	X(31,287),	X_MASK,   E500MC|PPCA2|PPCVLE, PPCNONE,	{RT, RA0, RB}},
 
-{"mfdcrux",	X(31,291),	X_MASK,      PPC464|PPCVLE, PPCNONE,	{RS, RA}},
+{"mfdcrux",	X(31,291),	X_MASK,      PPC464|PPCVLE|PPCA2, PPCNONE,	{RS, RA}},
 
 {"lvexhx",	X(31,293),	X_MASK,      PPCVEC2,	PPCNONE,	{VD, RA0, RB}},
 {"lvepx",	X(31,295),	X_MASK,      PPCVEC2|PPCVLE, PPCNONE,	{VD, RA0, RB}},
@@ -4683,12 +4980,12 @@
 {"mfsrr0",	XSPR(31,339, 26), XSPR_MASK, COM,	PPCNONE,	{RT}},
 {"mfsrr1",	XSPR(31,339, 27), XSPR_MASK, COM,	PPCNONE,	{RT}},
 {"mfcfar",	XSPR(31,339, 28), XSPR_MASK, POWER6,	PPCNONE,	{RT}},
-{"mfpid",	XSPR(31,339, 48), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RT}},
-{"mfcsrr0",	XSPR(31,339, 58), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RT}},
-{"mfcsrr1",	XSPR(31,339, 59), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RT}},
-{"mfdear",	XSPR(31,339, 61), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RT}},
-{"mfesr",	XSPR(31,339, 62), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RT}},
-{"mfivpr",	XSPR(31,339, 63), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RT}},
+{"mfpid",	XSPR(31,339, 48), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RT}},
+{"mfcsrr0",	XSPR(31,339, 58), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RT}},
+{"mfcsrr1",	XSPR(31,339, 59), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RT}},
+{"mfdear",	XSPR(31,339, 61), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RT}},
+{"mfesr",	XSPR(31,339, 62), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RT}},
+{"mfivpr",	XSPR(31,339, 63), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RT}},
 {"mfcmpa",	XSPR(31,339,144), XSPR_MASK, PPC860,	PPCNONE,	{RT}},
 {"mfcmpb",	XSPR(31,339,145), XSPR_MASK, PPC860,	PPCNONE,	{RT}},
 {"mfcmpc",	XSPR(31,339,146), XSPR_MASK, PPC860,	PPCNONE,	{RT}},
@@ -4922,7 +5219,7 @@
 
 {"sthepx",	X(31,415),	X_MASK,      E500MC|PPCA2|PPCVLE, PPCNONE, {RS, RA0, RB}},
 
-{"mtdcrux",	X(31,419),	X_MASK,      PPC464|PPCVLE, PPCNONE,	{RA, RS}},
+{"mtdcrux",	X(31,419),	X_MASK,      PPC464|PPCVLE|PPCA2, PPCNONE,	{RA, RS}},
 
 {"stvexhx",	X(31,421),	X_MASK,      PPCVEC2,	PPCNONE,	{VS, RA0, RB}},
 
@@ -5019,13 +5316,13 @@
 {"mtsrr0",	XSPR(31,467, 26), XSPR_MASK, COM|PPCVLE, PPCNONE,	{RS}},
 {"mtsrr1",	XSPR(31,467, 27), XSPR_MASK, COM|PPCVLE, PPCNONE,	{RS}},
 {"mtcfar",	XSPR(31,467, 28), XSPR_MASK, POWER6,	PPCNONE,	{RS}},
-{"mtpid",	XSPR(31,467, 48), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
-{"mtdecar",	XSPR(31,467, 54), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
-{"mtcsrr0",	XSPR(31,467, 58), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
-{"mtcsrr1",	XSPR(31,467, 59), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
-{"mtdear",	XSPR(31,467, 61), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
-{"mtesr",	XSPR(31,467, 62), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
-{"mtivpr",	XSPR(31,467, 63), XSPR_MASK, BOOKE|PPCVLE, PPCNONE,	{RS}},
+{"mtpid",	XSPR(31,467, 48), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
+{"mtdecar",	XSPR(31,467, 54), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
+{"mtcsrr0",	XSPR(31,467, 58), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
+{"mtcsrr1",	XSPR(31,467, 59), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
+{"mtdear",	XSPR(31,467, 61), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
+{"mtesr",	XSPR(31,467, 62), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
+{"mtivpr",	XSPR(31,467, 63), XSPR_MASK, BOOKE|PPCVLE|PPCA2, PPCNONE,	{RS}},
 {"mtcmpa",	XSPR(31,467,144), XSPR_MASK, PPC860,	PPCNONE,	{RS}},
 {"mtcmpb",	XSPR(31,467,145), XSPR_MASK, PPC860,	PPCNONE,	{RS}},
 {"mtcmpc",	XSPR(31,467,146), XSPR_MASK, PPC860,	PPCNONE,	{RS}},
@@ -5280,7 +5577,6 @@
 
 {"lwsync",	XSYNC(31,598,1), 0xffffffff, PPC,	E500,		{0}},
 {"ptesync",	XSYNC(31,598,2), 0xffffffff, PPC64,	PPCNONE,	{0}},
-{"sync",	X(31,598),	XSYNCLE_MASK,E6500,	PPCNONE,	{LS, ESYNC}},
 {"sync",	X(31,598),	XSYNC_MASK, PPCCOM|PPCVLE, BOOKE|PPC476, {LS}},
 {"msync",	X(31,598),	0xffffffff, BOOKE|PPCA2|PPC476, PPCNONE, {0}},
 {"sync",	X(31,598),	0xffffffff, BOOKE|PPC476, E6500,	{0}},
@@ -6086,7 +6382,7 @@
 {"drintxq",	ZRC(63,99,0),	Z2_MASK,     POWER6,	PPCNONE,	{R, FRTp, FRBp, RMC}},
 {"drintxq.",	ZRC(63,99,1),	Z2_MASK,     POWER6,	PPCNONE,	{R, FRTp, FRBp, RMC}},
 
-{"ftdiv",	X(63,128),   X_MASK|(3<<21), POWER7,	PPCNONE,	{BF, FRA, FRB}},
+{"ftdiv",	X(63,128),   X_MASK|(3<<21), POWER7|PPCA2,	PPCNONE,	{BF, FRA, FRB}},
 
 {"dcmpoq",	X(63,130),	X_MASK,      POWER6,	PPCNONE,	{BF, FRAp, FRBp}},
 
@@ -6098,12 +6394,12 @@
 {"fnabs",	XRC(63,136,0),	XRA_MASK,    COM,	PPCEFS,		{FRT, FRB}},
 {"fnabs.",	XRC(63,136,1),	XRA_MASK,    COM,	PPCEFS,		{FRT, FRB}},
 
-{"fctiwu",	XRC(63,142,0),	XRA_MASK,    POWER7,	PPCNONE,	{FRT, FRB}},
-{"fctiwu.",	XRC(63,142,1),	XRA_MASK,    POWER7,	PPCNONE,	{FRT, FRB}},
-{"fctiwuz",	XRC(63,143,0),	XRA_MASK,    POWER7,	PPCNONE,	{FRT, FRB}},
-{"fctiwuz.",	XRC(63,143,1),	XRA_MASK,    POWER7,	PPCNONE,	{FRT, FRB}},
+{"fctiwu",	XRC(63,142,0),	XRA_MASK,    POWER7|PPCA2,	PPCNONE,	{FRT, FRB}},
+{"fctiwu.",	XRC(63,142,1),	XRA_MASK,    POWER7|PPCA2,	PPCNONE,	{FRT, FRB}},
+{"fctiwuz",	XRC(63,143,0),	XRA_MASK,    POWER7|PPCA2,	PPCNONE,	{FRT, FRB}},
+{"fctiwuz.",	XRC(63,143,1),	XRA_MASK,    POWER7|PPCA2,	PPCNONE,	{FRT, FRB}},
 
-{"ftsqrt",	X(63,160), X_MASK|(3<<21|FRA_MASK), POWER7, PPCNONE,	{BF, FRB}},
+{"ftsqrt",	X(63,160), X_MASK|(3<<21|FRA_MASK), POWER7|PPCA2, PPCNONE,	{BF, FRB}},
 
 {"dtstexq",	X(63,162),	X_MASK,      POWER6,	PPCNONE,	{BF, FRAp, FRBp}},
 {"dtstdcq",	Z(63,194),	Z_MASK,      POWER6,	PPCNONE,	{BF, FRAp, DCM}},
Index: gprof/corefile.c
===================================================================
--- a/gprof/corefile.c	(.../tags/GNU_BASE/gnu/binutils-2.23.2)	(revision 62090)
+++ b/gprof/corefile.c	(.../branches/V1R2M3/gnu/binutils-2.23.2)	(revision 62090)
@@ -338,7 +338,7 @@
 core_sym_class (asymbol *sym)
 {
   symbol_info syminfo;
-  const char *name;
+//  const char *name;
   char sym_prefix;
   int i;
 
@@ -376,6 +376,7 @@
   /* Do some more filtering on static function-names.  */
   if (ignore_static_funcs)
     return 0;
+#if 0 /* With OMP in the XL compiler names with $ are generated so don't ignore them... */
 
   /* Can't zero-length name or funny characters in name, where
      `funny' includes: `.' (.o file names) and `$' (Pascal labels).  */
@@ -410,7 +411,7 @@
 	      return 0;
 	}
     }
-
+#endif
   /* On systems where the C compiler adds an underscore to all
      names, static names without underscores seem usually to be
      labels in hand written assembler in the library.  We don't want
